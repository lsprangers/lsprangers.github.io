<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search System - Ranking</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/career.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <header class="header" id="header">
        <img src="/images/mecircle.jpg" alt="Profile Photo" class="profile-photo">
        <h1>Luke Sprangers Blog</h1>
        <button class="mobile-nav-toggle" id="mobileNavToggle">
            <i class="fas fa-bars"></i>
        </button>
    </header>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <nav>
                    <ul>
                        <li><a href="/">Home</a></li>
                        <li><a href="/career/">Career</a></li>
                        <li><a href="/projects/">Projects</a></li>
                        <li class="nav-item">
                            <a href="/technical/" onclick="toggleSubNav(event)">Technical Content</a>
                            <ul class="sub-nav" id="technicalSubNav" style="display: none;">
                                <li><a href="/technical/design_systems/search_system/">Search System</a></li>
                                <li><a href="/technical/design_systems/url_shortening_system/">URL Shortener</a></li>
                                <li><a href="/technical/design_systems/youtube/">YouTube System</a></li>
                                <li><a href="/technical/design_systems/top_k/">Top-K Problem</a></li>
                                <li><a href="/technical/design_systems/_typical_reusable_resources/">Reusable Resources</a></li>
                                <li><a href="/technical/design_systems/_reference_material/">Reference Materials</a></li>
                                <li><a href="/technical/design_systems/calculations_and_timings/">Calculations & Timings</a></li>
                            </ul>
                        </li>
                        <li><a href="/contact/">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </aside>
        <main class="content">
            <article class="technical-article">
    <div class="technical-header">
        <div class="technical-meta">
            <span class="technical-category">Search System Design</span>
            <span class="technical-difficulty advanced">Advanced</span>
        </div>
        <h1>Search System - Ranking</h1>
        
        <p class="technical-description">Discussion around Ranking, the final area in search and recommendation systems</p>
        
    </div>
    
    <div class="technical-content">
        <h1 id="table-of-contents">Table of Contents</h1>
<ul>
  <li><a href="#ranking">Ranking</a>
    <ul>
      <li><a href="#count-based-heuristics">Count Based Heuristics</a>
        <ul>
          <li><a href="#tf-idf--bm25">TDIDF / BM25</a></li>
        </ul>
      </li>
      <li><a href="#probabilistic-models">Probabilistic Models</a>
        <ul>
          <li><a href="#bayesian-proba">Bayesian Proba</a></li>
          <li><a href="#learn-to-rank">Learn To Rank</a></li>
        </ul>
      </li>
      <li><a href="#graph">Graph</a>
        <ul>
          <li><a href="#page-rank">Page Rank</a></li>
        </ul>
      </li>
      <li><a href="#embeddings">Embeddings</a></li>
    </ul>
  </li>
</ul>

<p>TODO: A lot of these are offline, and some are online, and the Ranking section should actually discuss Ranking + Scoring</p>

<h1 id="ranking">Ranking</h1>
<p>Ranking queries to items is a fairly large part of a search system, otherwise you’re just returning a big list of documents when some might be much more relevant to user</p>

<p>Ranking is typically the second stage of a recommender system, and sometimes it’s <strong><em>online</em></strong> meaning a new ranking calculations per query, <strong><em>offline</em></strong> where we can calculate results and look them up per query, or somewhere inbetween</p>

<p>Ranking is typically used for experiments, explainable results, or something different that we want to calculate specifically on each Item that might be more resource intensive than Candidate Generation methods, and other systems will combine everything into one single API call and bypass the different layers</p>

<ul>
  <li>Ranking methods can take features of queries, documents, and their interactions as input to predict a relevance score for each document
    <ul>
      <li>Features might include:
        <ul>
          <li>Query-Document similarity (e.g., cosine similarity, TF-IDF, BM25)</li>
          <li>Document-specific features (e.g., PageRank, click-through rate)</li>
          <li>Query-specific features (e.g., query length, query type)</li>
          <li>Contextual features (e.g., user location, device type)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Example:
    <ul>
      <li>Query: “Best laptops under $1000”</li>
      <li>Document Features:
        <ul>
          <li>Price: $900</li>
          <li>Brand popularity: High</li>
          <li>User reviews: 4.5/5</li>
        </ul>
      </li>
      <li>Query-Document Features:
        <ul>
          <li>BM25 score: 1.2</li>
          <li>Query terms in title: 2/3</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="count-based-heuristics">Count Based Heuristics</h2>
<p>One of the most common ranking / scoring methodologies is using the uniqueness of a word based on specific counts (heuristics) - the word “and” is not very unique, and if it shows up in a document we won’t really care. Another word like “aardvark” is fairly unique and not used that often, so it would be more unique</p>

<h3 id="tf-idf">TF-IDF</h3>
<p>TF-IDF means Term Frequency Inverse Document Frequency, and it’s a fairly simple scoring mechanism for computing the uniqueness of a Term (word) across Documents. Most of the calculations are done offline, and for a query we use our lookup table to find Documents.</p>

<ul>
  <li><strong>TF (Term Frequency)</strong>: The count of a term in a specific document.</li>
  <li><strong>IDF (Inverse Document Frequency)</strong>: The logarithm of the total number of documents divided by the number of documents that contain the term.</li>
</ul>

<p>The TF-IDF score is calculated as:
[ \text{TF-IDF} = \text{TF} \times \text{IDF} ]
[ \text{TF-IDF}(\text{Term}, \text{Doc}) = \text{count}(\text{term in Doc}) \times \log\left(\frac{\text{count}(\text{docs})}{\text{count}(\text{docs containing term})}\right) ]</p>

<table>
  <thead>
    <tr>
      <th>TF</th>
      <th>IDF</th>
      <th>Meaning</th>
      <th>TFIDF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>High</td>
      <td>High</td>
      <td>This word is common among all documents, and this document, so it’s just a generally common word</td>
      <td>Fairly normal score - around mean value</td>
    </tr>
    <tr>
      <td>High</td>
      <td>Low</td>
      <td>This word is rare throughout the other documents, but comes up a lot in this document, so it must be reasonably relevant for this document</td>
      <td>High score</td>
    </tr>
    <tr>
      <td>Low</td>
      <td>High</td>
      <td>This word is a common word, and it’s not even showing up much in this document</td>
      <td>Low Score</td>
    </tr>
    <tr>
      <td>Low</td>
      <td>Low</td>
      <td>This word isn’t very common, but it’s also not apart of this document, so it’s not very relevant</td>
      <td>Low but closer to mean</td>
    </tr>
  </tbody>
</table>

<p><img src="./images/inverted_index_tfidf.png" alt="General Architecture of TFIDF" /></p>

<h3 id="bm25">BM25</h3>
<ul>
  <li><strong><em>Description</em></strong>: An extension of TF-IDF that considers term frequency saturation and document length normalization.</li>
  <li><strong><em>Formula</em></strong>: 
$text{BM25}(D, Q) = \sum_{i=1}^{n} IDF(q_i) \cdot \frac{f(q_i, D) \cdot (k_1 + 1)}{f(q_i, D) + k_1 \cdot (1 - b + b \cdot \frac{|D|}{\text{avgdl}})}$
    <ul>
      <li>$ f(q_i, D) $ is the term frequency of $( q_i )$ in document $( D )$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>D</td>
              <td>$ is the length of the document</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>$ \text{avgdl} $ is the average document length</li>
      <li>$ k_1 $ and $ b $ are parameters</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="probabilistic-models">Probabilistic Models</h2>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Probabilistic Models estimate the likelihood of a query given a document! $P(Query</td>
          <td>Document)$</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>The document with the highest probability is considered the most relevant.</li>
    </ul>
  </li>
</ul>

<h3 id="bayesian-proba">Bayesian Proba</h3>
<ul>
  <li>A Bayesian Approach in Statistics is a way of using Bayes’ Theorem to iteratively update the probability of a hypothesis as more evidence becomes available.
    <ul>
      <li>This is in constrast to Frequentist Statistics which doesn’t incorporate prior beliefs or evidence into the analysis.</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Likelihood in Bayesian Stastics is $P(Evidence</td>
              <td>Hypothesis)$ meaning what’s the chance we saw this new evidence based on what we believe?</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Posterior Probability is $P(Hypothesis</td>
              <td>Evidence)$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Using these two formulas, we update our Prior Probability, i.e. initial Probability $P(Hypothesis)$ with the Likelihood we saw our Posterior, i.e. new evidence, Probability
        <ul>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>$ P(H</td>
                  <td>E) = \frac{P(E</td>
                  <td>H) \cdot P(H)}{P(E)}$ where $P(E)$ is the total probability of seeing our new Evidence</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>A Bayesian Approach to this would be instead of finding the most relevant Document per Query, we flip it around and try to estimate the likelihood of the Query for every Document</li>
  <li>How is this used in the world?
    <ul>
      <li>Most of the Documents will get some sort of score per Term, typically using TF-IDF or BM25.
        <ul>
          <li>At this point, we have scores across <code class="language-plaintext highlighter-rouge">(Term, Document)</code> pairs, and this can be thought of as the Likelihood of a Term given a Document.</li>
          <li>For a specific Term, the Marginal Likelihood is:
[
P(Term) = \sum_{\text{docs}} P(Term|Document) \cdot P(Document)
]</li>
          <li>Posterior Probability is:
[
P(\text{Document} | \text{Term}) = \frac{P(\text{Term} | \text{Document}) \cdot P(\text{Document})}{P(\text{Term})}
]</li>
        </ul>
      </li>
      <li>And then you get the Probability of a Document for each Term, and when your Query comes in it’s simply a bunch of terms strung together so you’d find the top Documents for each Term in the Query and Rank the result set</li>
    </ul>
  </li>
</ul>

<h3 id="decision-trees">Decision Trees</h3>
<p>We cover <a href="../../other_concepts/DECISION_TREES.md">Decision Trees</a> in depth elsewhere, but they are useful for taking many of our Document, Query-Document, and User features into consideration when we want to predict some general category, but they can’t really be used on predicting specific videos</p>

<p>Decision Tree’s roles are typically to predict relevance scores (pointwise) or to optimize ranking orders based on features (listwise). We can incorporate them in <a href="#learn-to-rank">Learning To Rank</a> to optimize ranking orders</p>
<ul>
  <li>Pointwise:
    <ul>
      <li>Treats ranking as a regression or classification problem.</li>
      <li>Each document is scored independently, and the scores are used to rank the documents.</li>
      <li>Example: Predicting a relevance score for each video in a search result.</li>
    </ul>
  </li>
  <li>Pairwise:
    <ul>
      <li>Optimizes the relative ordering of document pairs.</li>
      <li>The model learns to predict which document in a pair is more relevant.</li>
      <li>Example: Comparing two videos and predicting which one should rank higher.</li>
    </ul>
  </li>
  <li>Listwise:
    <ul>
      <li>Directly optimizes the ranking of a list of documents.</li>
      <li>The model learns to minimize a loss function that quantifies the quality of the entire ranking.</li>
    </ul>
  </li>
  <li>Example: Optimizing the ranking of a list of videos for a query.</li>
  <li>Offline Training:
    <ul>
      <li>Decision trees are typically trained offline using labeled data, where each query-document pair has a relevance label (e.g., 1 for relevant, 0 for irrelevant)</li>
      <li>Once trained, the model can be used online to rank documents for new queries</li>
    </ul>
  </li>
</ul>

<h3 id="logistic-regression">Logistic Regression</h3>
<p>TODO: Logistic regression</p>

<h3 id="learn-to-rank">Learn To Rank</h3>
<ul>
  <li>A machine learning <strong><em>task</em></strong> that seeks to train models that rank documents based on features extracted from the documents and queries. Each new query results in a forward pass / inference call, so this would be an online model
    <ul>
      <li>A classification task is a model whose task is to classify inputs into certain classification buckets, so a Learn To Rank Task is a model whose task is to rank documents based on features extracted from documents</li>
    </ul>
  </li>
  <li>A Learning to Rank task is when your input is a set of samples, all with their given features, but the aim is to build a model that outputs a ranking in terms of their relevancy
    <ul>
      <li>Therefore <em>the output is a ranking of input samples</em></li>
    </ul>
  </li>
  <li>Learning To Rank Training Samples:
<code class="language-plaintext highlighter-rouge">[Query ID, Sample ID, [Features of that sample], Relevancy (Target)]</code></li>
  <li>(Google) LTR task that tries to rank pages from a Query
    <ul>
      <li><strong><em>Query ID</em></strong>: If we scrape the web with 100 web calls, this is 1-100</li>
      <li><strong><em>Sample ID</em></strong>: The ID of the object, so this would actually just be the URL</li>
      <li><strong><em>Features</em></strong>: Any sort of metadata features, binary features, etc… about the example
        <ul>
          <li>Number of Query Terms in the Page</li>
          <li>Total number of “good” links inside the page</li>
          <li>TF-IDF of Query Terms to Page Terms (Document)</li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>Bayesian Probability $P(Query</td>
                  <td>Page)$</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>etc…</li>
        </ul>
      </li>
      <li><strong><em>Relevance ID</em></strong>: A ranking 1 (Least Relevant) to 4 (Most Relevant)</li>
    </ul>
  </li>
  <li>(Amazon) LTR task that tries to rank “Also Buy Items” (Item2) after someone puts another item (Item1) in their cart
    <ul>
      <li><strong><em>Query ID</em></strong>: Item1</li>
      <li><strong><em>Sample ID</em></strong>: The ID of the object, Item2</li>
      <li><strong><em>Features</em></strong>: Any sort of metadata features, binary features, etc… about the Item2
        <ul>
          <li>Collaborative filtered similar users who purchased this item</li>
          <li>Item2 embedding similarity to Item1</li>
          <li>1 or 0: In same product family</li>
          <li>1 or 0: Bought in last 3 weeks</li>
          <li>etc…</li>
        </ul>
      </li>
      <li><strong><em>Relevance ID</em></strong>: A ranking 1 (Least Relevant) to 4 (Most Relevant)</li>
    </ul>
  </li>
  <li>
    <p>Features related to the Query are known as <strong><em>Context Features</em></strong></p>
  </li>
  <li>LTR Types
    <ul>
      <li><strong>Pointwise</strong>: Treats ranking as a regression or classification problem.
        <ul>
          <li>Directly predict the ranking of inputs (4,3,2,1)</li>
        </ul>
      </li>
      <li><strong>Pairwise</strong>: Optimizes the ordering of document pairs.
        <ul>
          <li>Takes two samples, A and B, and runs them through the model - if A has higher relevance but it ranked B higher it will result in a larger loss</li>
          <li>Doesn’t quantify the extent of the incorrect rankings</li>
        </ul>
      </li>
      <li><strong>Listwise</strong>: Directly optimizes the ranking of a list of documents.
        <ul>
          <li>Listwise takes Pairwise a step further and directly quantifies the extent of the incorrect rankings, and then updates the weights accordingly via specified loss</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="graph">Graph</h2>
<p>I can really only think of PageRank off the top of my head, and in PageRank the Features are taken from a graph linkage structure, but it doesn’t need to be ran on a graph engine. Most of the time we calculate PageRank scores offline, and then for a specific query we use PageRank as a feature along with other ranking mechanisms.</p>

<p>Page Rank simply helps us calculate “page importance”, but we still need to compare a query to web page terms and themes by doing lookups based on <a href="../../nn_and_llm/EMBEDDINGS.md#embeddings">Document and Query Embedding Similarity</a></p>

<h3 id="page-rank">Page Rank</h3>
<p>An algorithm used by Google Search to rank web pages. It measures the importance of a page based on the number and quality of links to it. PageRank can be used anywhere, not just in Ranking, but makes sense to put it here</p>

<p>It outputs a probability distribution used to represent the likelihood that a person will arrive at any particular page through clicking on random links, similar to probability distribution of the “Wikipedia game” where to try to get to Page B from Page A by visiting referenced links starting at A</p>

<p>PageRank can be solved using iterations and traversing web links using the <strong><em>power iteration method</em></strong>, but it can also be solved analytically if we had an adjacency matrix of all links between pages $M$, where $M[i][j]$ represents the link from page $j$ to page $i$</p>

<ul>
  <li><strong>Analytical Formula</strong>:
    <ul>
      <li>The PageRank vector $PR$ satisfies the equation: $PR = d \cdot M \cdot PR + (1 - d) \cdot v$ where:
        <ul>
          <li>$d$ is the damping factor (typically ( 0.85 )).</li>
          <li>$v$ is a personalization vector (often uniform, representing equal probability of jumping to any page).</li>
          <li>Rearranging: $PR = (I - d \cdot M)^{-1} \cdot (1 - d) \cdot v$</li>
          <li>Here, $I$ is the identity matrix, and $(I - d \cdot M)^{-1}$ is the inverse of $I - d \cdot M$.</li>
        </ul>
      </li>
      <li>This provides an exact solution for PageRank, but computing the inverse of a matrix is computationally expensive for large graphs, making this approach impractical for real-world web-scale graphs.</li>
    </ul>
  </li>
  <li><strong>Iterative Formula</strong>:
    <ul>
      <li>Start with an initial $PR[n]$ vector of size $N$ initialized uniformly $PR[0] = \frac{1}{N}$</li>
      <li>At each step $k$ calculate the $PR$ vector $ PR[k+1] = d \cdot M \cdot PR[k] + (1 - d) \cdot v $</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>Repeat this until the difference between successive iterations is below a small enough threshold, $\epsilon$, in total so $</td>
              <td>PR[k+1] - PR[k]</td>
              <td>&lt; \epsilon$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>Another way to calculate $PR[A]$ without matrix inversion would be to traverse in-nodes
        <ul>
          <li>$PR(A) = (1 - d) + d \left( \frac{PR(T_1)}{C(T_1)} + \frac{PR(T_2)}{C(T_2)} + \ldots + \frac{PR(T_n)}{C(T_n)} \right)$
            <ul>
              <li>$d$ is the damping factor,</li>
              <li>$PR(T_i)$ is the PageRank of page $T_i$ and</li>
              <li>$C(T_i)$ is the number of outbound links on page $T_i$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The iterative approach using sum over in-nodes is typically preferred for large graphs because it avoids the computational cost of matrix inversion, and reduces amount that needs to be stored</p>

<h2 id="dnn-for-ranking">DNN For Ranking</h2>
<p>TODO: Most use cases today use DNN or GBDT for Ranking</p>

    </div>
    
    <div class="technical-footer">
        <p><i class="fas fa-arrow-left"></i> <a href="/technical/">Back to Technical Content</a></p>
    </div>
</article> 
        </main>
    </div>
    <script>
        window.addEventListener('scroll', function() {
            var header = document.getElementById('header');
            var sidebar = document.getElementById('sidebar');
            if (window.scrollY > 50) {
                header.style.top = '-100px'; // Hide the header
                sidebar.style.top = '0'; // Move sidebar to the top
            } else {
                header.style.top = '0'; // Show the header
                sidebar.style.top = '60px'; // Position sidebar below the header
            }
        });

        // Mobile navigation functionality
        const mobileNavToggle = document.getElementById('mobileNavToggle');
        const sidebar = document.getElementById('sidebar');
        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
            // Reset sidebar position for mobile
            sidebar.style.top = '0';
        }

        mobileNavToggle.addEventListener('click', function() {
            sidebar.classList.toggle('active');
        });

        // Close sidebar when clicking on a link (mobile)
        const sidebarLinks = sidebar.querySelectorAll('a');
        sidebarLinks.forEach(link => {
            link.addEventListener('click', function() {
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('active');
                }
            });
        });

        // Close sidebar when clicking outside (mobile)
        document.addEventListener('click', function(event) {
            if (window.innerWidth <= 768) {
                const isClickInsideSidebar = sidebar.contains(event.target);
                const isClickOnToggle = mobileNavToggle.contains(event.target);
                
                if (!isClickInsideSidebar && !isClickOnToggle && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                }
            }
        });

        // Sub-navigation toggle
        function toggleSubNav(event) {
            event.preventDefault();
            const subNav = document.getElementById('technicalSubNav');
            if (subNav.style.display === 'none') {
                subNav.style.display = 'block';
            } else {
                subNav.style.display = 'none';
            }
        }

    </script>
</body>
</html>