<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Communication Protocols</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/career.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <header class="header" id="header">
        <img src="/images/mecircle.jpg" alt="Profile Photo" class="profile-photo">
        <h1>Luke Sprangers Blog</h1>
        <button class="mobile-nav-toggle" id="mobileNavToggle">
            <i class="fas fa-bars"></i>
        </button>
    </header>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <nav>
                    <ul>
                        <li><a href="/">Home</a></li>
                        <li><a href="/career/">Career</a></li>
                        <li><a href="/projects/">Projects</a></li>
                        <li class="nav-item">
                            <a href="/technical/" onclick="toggleSubNav(event)">Technical Content</a>
                            <ul class="sub-nav" id="technicalSubNav" style="display: none;">
                                <li><a href="/technical/design_systems/search_system/">Search System</a></li>
                                <li><a href="/technical/design_systems/url_shortening_system/">URL Shortener</a></li>
                                <li><a href="/technical/design_systems/youtube/">YouTube System</a></li>
                                <li><a href="/technical/design_systems/top_k/">Top-K Problem</a></li>
                                <li><a href="/technical/design_systems/_typical_reusable_resources/">Reusable Resources</a></li>
                                <li><a href="/technical/design_systems/_reference_material/">Reference Materials</a></li>
                                <li><a href="/technical/design_systems/calculations_and_timings/">Calculations & Timings</a></li>
                            </ul>
                        </li>
                        <li><a href="/contact/">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </aside>
        <main class="content">
            <article class="technical-article">
    <div class="technical-header">
        <div class="technical-meta">
            <span class="technical-category">Architecture Components</span>
            <span class="technical-difficulty advanced">Advanced</span>
        </div>
        <h1>Communication Protocols</h1>
        
        <p class="technical-description">Discussion around Protocols including HTTP, gRPC, and others</p>
        
    </div>
    
    <div class="technical-content">
        <h1 id="table-of-contents">Table of Contents</h1>
<h1 id="--protocols">- <a href="#protocols">Protocols</a></h1>
<h1 id="--protocols-in-the-wild">- <a href="#protocols-in-the-wild">Protocols In The Wild</a></h1>

<h1 id="protocols">Protocols</h1>
<p>The biggest gap most people have in their understanding of distributed systems is the protocols that are used to communicate between the different components</p>

<p>This is a very high level overview of some of the most common protocols used in distributed systems, and how they work - async vs sync, push vs pull, HTTP vs gRPC, etc</p>

<h2 id="asynchronous-vs-synchronous">Asynchronous vs Synchronous</h2>
<ul>
  <li><strong>Asynchronous</strong>: Communication occurs without waiting for a response. The sender sends a message and continues processing without waiting for the receiver to acknowledge receipt.
    <ul>
      <li>Example: Message queues, event-driven architectures</li>
    </ul>
  </li>
  <li><strong>Synchronous</strong>: Communication occurs with a request-response pattern. The sender sends a message and waits for the receiver to acknowledge receipt before continuing.
    <ul>
      <li>Example: HTTP requests, gRPC calls</li>
    </ul>
  </li>
</ul>

<h2 id="push-vs-pull">Push vs Pull</h2>
<ul>
  <li><strong>Push</strong>: The sender pushes data to the receiver without waiting for a request. The receiver must be able to handle incoming data at any time.
    <ul>
      <li>Example: Webhooks, server-sent events</li>
    </ul>
  </li>
  <li><strong>Pull</strong>: The receiver requests data from the sender. The sender responds with the requested data.
    <ul>
      <li>Example: REST APIs, GraphQL queries</li>
    </ul>
  </li>
</ul>

<h2 id="http-vs-grpc">HTTP vs gRPC</h2>
<p>The TLDR; of these two is that HTTP is useful when you can’t have both client and server accessing files inbetween (IDL schema files), and so they have to communicate with generic HTTP messages that send over data in JSON, XML, or other common formats. HTTP API’s do typically have open source documentation like OpenAPI / Swagger, which one could argue is a “shared schema”…so maybe this is a moot point</p>

<p>If I setup an API to access some functionality, I don’t want to setup the client on every persons phone to have an updated schema definition everytime my schema changes, so I’ll just use a generic REST API, but if I have 2 services in my own private network that can have constant CICD and coupled / monitored updates then gRPC is faster and more performant</p>

<p>ChatGPT answer:
    - HTTP: Best for external-facing APIs where flexibility and compatibility with a wide range of clients (e.g., browsers, mobile apps) are more important than performance.
    - gRPC: Best for internal microservices communication where performance, strict schema enforcement, and features like streaming are critical.</p>

<ul>
  <li><strong>HTTP</strong>: A stateless protocol used for communication between clients and servers. It is widely used for RESTful APIs and web applications
    <ul>
      <li>Example: REST APIs, GraphQL APIs</li>
    </ul>
  </li>
  <li><strong>gRPC</strong>: A high-performance, open-source RPC framework that uses HTTP/2 for transport and Protocol Buffers for serialization. It supports bi-directional streaming and is designed for low-latency communication
    <ul>
      <li>Example: Microservices communication, real-time applications
        <ul>
          <li>A producer calls a remote function (e.g., processDocument()) on a consumer, which performs the task and returns the result.</li>
        </ul>
      </li>
      <li>Typically more efficient than HTTP for internal communication due to binary serialization (e.g., gRPC)</li>
      <li>A protocol that allows a program to execute a procedure on a remote server as if it were a local function</li>
      <li>RPC will <strong><em>serialize the data</em></strong> and <strong><em>the response</em></strong> between the different functions, but doesn’t necessarily serialize the function itself
        <ul>
          <li>This is why you need to have IDL schemas in files that can be accessed between the 2 servers
            <ul>
              <li>IDL: Avro <code class="language-plaintext highlighter-rouge">.avsc</code>, Proto <code class="language-plaintext highlighter-rouge">.proto</code>, etc…</li>
              <li>Then both servers will be able to create getter, setter, and caller methods so that server1 can call server2 which will run a specific function
```
syntax = “proto3”;</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>service DocumentService {
    rpc ProcessDocument (ProcessDocumentRequest) returns (ProcessDocumentResponse);
}</p>

<p>message ProcessDocumentRequest {
    string arg1 = 1;
    nt32 arg2 = 2;
}</p>

<p>message ProcessDocumentResponse {
    string result = 1;
}
```</p>

<h3 id="serializable-calls">Serializable Calls</h3>
<p><a href="../messaging/Queue/QUEUE.md#celery">Celery</a> <strong><em>is not gRPC</em></strong>, but can be thought of in a similar vein where you serialize a function along with it’s arguments, and send it somewhere else to be executed</p>

<p>There is nothing new about serializing something to unpack somewhere else</p>

<p>gRPC is actually a superset of HTTP, and is built on top of HTTP/2. It uses Protocol Buffers (protobuf) for serialization, which is more efficient than JSON used in traditional HTTP APIs. gRPC also supports features like authentication, load balancing, and bidirectional streaming.</p>

<h2 id="websockets">WebSockets</h2>
<ul>
  <li><strong>WebSockets</strong>: A protocol that provides full-duplex communication channels over a single TCP connection. It is used for real-time applications where low latency is required.
    <ul>
      <li>Example: Chat applications, online gaming</li>
    </ul>
  </li>
</ul>

    </div>
    
    <div class="technical-footer">
        <p><i class="fas fa-arrow-left"></i> <a href="/technical/">Back to Technical Content</a></p>
    </div>
</article> 
        </main>
    </div>
    <script>
        window.addEventListener('scroll', function() {
            var header = document.getElementById('header');
            var sidebar = document.getElementById('sidebar');
            if (window.scrollY > 50) {
                header.style.top = '-100px'; // Hide the header
                sidebar.style.top = '0'; // Move sidebar to the top
            } else {
                header.style.top = '0'; // Show the header
                sidebar.style.top = '60px'; // Position sidebar below the header
            }
        });

        // Mobile navigation functionality
        const mobileNavToggle = document.getElementById('mobileNavToggle');
        const sidebar = document.getElementById('sidebar');
        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
            // Reset sidebar position for mobile
            sidebar.style.top = '0';
        }

        mobileNavToggle.addEventListener('click', function() {
            sidebar.classList.toggle('active');
        });

        // Close sidebar when clicking on a link (mobile)
        const sidebarLinks = sidebar.querySelectorAll('a');
        sidebarLinks.forEach(link => {
            link.addEventListener('click', function() {
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('active');
                }
            });
        });

        // Close sidebar when clicking outside (mobile)
        document.addEventListener('click', function(event) {
            if (window.innerWidth <= 768) {
                const isClickInsideSidebar = sidebar.contains(event.target);
                const isClickOnToggle = mobileNavToggle.contains(event.target);
                
                if (!isClickInsideSidebar && !isClickOnToggle && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                }
            }
        });

        // Sub-navigation toggle
        function toggleSubNav(event) {
            event.preventDefault();
            const subNav = document.getElementById('technicalSubNav');
            if (subNav.style.display === 'none') {
                subNav.style.display = 'block';
            } else {
                subNav.style.display = 'none';
            }
        }

    </script>
</body>
</html>