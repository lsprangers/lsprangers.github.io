<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Databases & Storage - Disk Based Storage</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/career.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <header class="header" id="header">
        <img src="/images/mecircle.jpg" alt="Profile Photo" class="profile-photo">
        <h1>Luke Sprangers Blog</h1>
        <button class="mobile-nav-toggle" id="mobileNavToggle">
            <i class="fas fa-bars"></i>
        </button>
    </header>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <nav>
                    <ul>
                        <li><a href="/">Home</a></li>
                        <li><a href="/career/">Career</a></li>
                        <li><a href="/projects/">Projects</a></li>
                        <li><a href="/technical/">Technical Content</a></li>
                        <li><a href="/contact/">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </aside>
        <main class="content">
            <article class="technical-article">
    <div class="technical-header">
        <div class="technical-meta">
            <span class="technical-category">Architecture Components</span>
            <span class="technical-difficulty advanced">Advanced</span>
        </div>
        <h1>Databases & Storage - Disk Based Storage</h1>
        
        <p class="technical-description">Discussion around Disk Based Databases</p>
        
    </div>
    
    <div class="technical-content">
        <h1 id="disk-based-storage">Disk Based Storage</h1>
<p>Disk based storage underpins almost all “durable storage” systems</p>

<p>Most of the core concepts are the same as volatile memory data structures, except we take these generic data structures and write them to block storage</p>

<ul>
  <li>Common Disk Based Structures:
    <ul>
      <li>Tree Based:
        <ul>
          <li>B-Tree</li>
          <li>Log Structured Merge (LSM) Tree</li>
        </ul>
      </li>
      <li>Tabular Storage
        <ul>
          <li>Columnar / Column Oriented Storage</li>
          <li>Row Oriented Storage</li>
        </ul>
      </li>
      <li>List Based
        <ul>
          <li>Linked List</li>
          <li>Doubly Linked List</li>
          <li>Skip List</li>
          <li>Bloom Filter?</li>
        </ul>
      </li>
      <li>Hash Table</li>
      <li>Graph Based
        <ul>
          <li>Trie</li>
          <li>Generic Graph
            <ul>
              <li>Specifically, using Parquet for Pregel based graphs</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="tree-based">Tree Based</h1>
<p>Some open source databases use a B-Tree or LSM-Tree as their primary storage engine such as:</p>
<ul>
  <li>B-Tree
    <ul>
      <li>MySQL</li>
      <li>PostgreSQL</li>
      <li>SQLite</li>
    </ul>
  </li>
  <li>LSM-Tree
    <ul>
      <li>Cassandra</li>
      <li>HBase</li>
      <li>RocksDB</li>
    </ul>
  </li>
  <li>At a high level:
    <ul>
      <li><em>BTree’s are better for reads and worse for writes</em> because they are self balancing and require more compute cycles per write, but they’re still incredibly fast for disk write structures</li>
      <li><em>LSMTrees are better for writes and worse for reads</em> because you quickly write the data to MemTable and then forget about it, and background processes ensure it’s durable</li>
      <li>Both are:
        <ul>
          <li>Durable</li>
          <li>Consistent (I think)</li>
          <li>Relatively $O(log n)$ read
            <ul>
              <li>Tree lookups can degrade to $O(n)$ if we don’t search on the primary sort key</li>
              <li>It would force us to do a full scan of the data until we find the key with a specific attribute, and any range queries are guaranteed $O(n)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="b-tree">B-Tree</h2>
<ul>
  <li>B-Trees are self-balancing data structures, meaning writes take a bit more time to ensure that reads are always $O (\log n)$</li>
  <li>Leaf nodes hold references to sorted records</li>
  <li>Internal / parent nodes hold references to other nodes</li>
  <li>Writes
    <ul>
      <li>As new records come in the leaf nodes are updated, and the tree is re-balanced</li>
      <li>B-Tree good for reads, worse for writes</li>
    </ul>
  </li>
  <li>Reads
    <ul>
      <li>Because of the binary search tree structure, reads are very efficient and usually complete in &lt; 5 hops</li>
    </ul>
  </li>
  <li>B-Tree is a good choice for indexing in relational databases, especially when range queries are required
    <ul>
      <li>B-Trees are commonly used in relational databases for indexing columns, especially when range queries are required</li>
    </ul>
  </li>
</ul>

<h2 id="lsm-tree">LSM-Tree</h2>
<ul>
  <li>Structured as Levels of Sorted Runs</li>
  <li>Sorted Run - Lis of records sorted by key on disk
    <ul>
      <li>Sorted runs organized into Levels based on max storage of that level</li>
      <li>Compaction
        <ul>
          <li>When current level is full / at max, a Sorted Run is moved to the next level and merged with other sorted runs
            <ul>
              <li>Merged with other runs with overlapping key ranges</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>LSM-Tree good for writes, worse for reads</li>
  <li>Reads
    <ul>
      <li>Reads are done by searching the MemTable, and then searching the SSTables in order from lowest to highest level</li>
      <li>This means that reads can be $O(n)$ if there are a lot of levels</li>
    </ul>
  </li>
  <li>Writes
    <ul>
      <li>Writes are done by writing to the MemTable, and then flushing the MemTable to disk when it is full</li>
      <li>This means that writes are $O(1)$, but reads can be $O(n)$ if there are a lot of levels</li>
    </ul>
  </li>
</ul>

<h3 id="lsmtree-implementation">LSMTree Implementation</h3>
<p>We discuss LSMTree implementations in more detail in the <a href="./LSMTREE.md#implementation">LSMTree Sub-Document</a>, but the 3 main components are:</p>
<ul>
  <li><strong><em>MemTable</em></strong>
    <ul>
      <li>Can be any sort of container that supports sorting keys, and scanning retrieval
        <ul>
          <li>Insert and search can both be O(log n) with a simple Vector</li>
          <li>RocksDB uses a Skip List which is a Linked List with multiple other links that you can use to skip</li>
          <li>Skip Lists still have, on average, O(log n) search without O(n) insert which can happen with a Vector if it’s full</li>
          <li>Can’t use a Hash Map because scans would be O(n)</li>
        </ul>
      </li>
      <li>Since we write to MemTable in O(log n) in RAM, and then write this to disk as SSTable later on, writes are fast</li>
      <li>Still durable because of WAL</li>
      <li>We remove need for random disk writes which is how B-Tree would handle it</li>
    </ul>
  </li>
  <li><strong><em>WAL</em></strong>
    <ul>
      <li>On disk backup for MemTable</li>
      <li>Just an append only log of transactions</li>
      <li>Uses Sequential I/O and not Random I/O
        <ul>
          <li>Sequential I/O is faster, but uses up a lot of disk space because each time a record is updated older versions are kept</li>
          <li>Space Amplification is the amount of disk space per actual database - so if a 1GB Dataset uses 2GB of disk space, it’s space amplification is 2</li>
        </ul>
      </li>
      <li>Space Amplification is the amount of disk space per actual database - so if a 1GB Dataset uses 2GB of disk space, it’s space amplification is 2</li>
    </ul>
  </li>
  <li><strong><em>SSTable</em></strong>
    <ul>
      <li>When a MemTable is flushed to disk, we take that Sorted Run and store it on disk as an SSTable
        <ul>
          <li>i.e. when we want to write MemTable to disk, we store it as an SSTable</li>
        </ul>
      </li>
      <li>SSTables are organized into levels with max capacities of powers
        <ul>
          <li>10MB, 100MB, etc…</li>
          <li>Whenever any level reaches capacity, it’s Compacted into next level</li>
          <li>This means older records will persist on disk in older SSTables until updated</li>
        </ul>
      </li>
      <li>Compaction
        <ul>
          <li>Our garbage collection and data management process of our database</li>
          <li>Compaction takes SSTable from filled level and merges it with SSTables in next level with overlapping key ranges
            <ul>
              <li>When files are merged we:
                <ul>
                  <li>Re-sort keys</li>
                  <li>Outdated records are removed</li>
                  <li>New SSTable is created</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

    </div>
    
    <div class="technical-footer">
        <p><i class="fas fa-arrow-left"></i> <a href="/technical/">Back to Technical Content</a></p>
    </div>
</article> 
        </main>
    </div>
    <script>
        window.addEventListener('scroll', function() {
            var header = document.getElementById('header');
            var sidebar = document.getElementById('sidebar');
            if (window.scrollY > 50) {
                header.style.top = '-100px'; // Hide the header
                sidebar.style.top = '0'; // Move sidebar to the top
            } else {
                header.style.top = '0'; // Show the header
                sidebar.style.top = '60px'; // Position sidebar below the header
            }
        });

        // Mobile navigation functionality
        const mobileNavToggle = document.getElementById('mobileNavToggle');
        const sidebar = document.getElementById('sidebar');
        const isMobile = window.innerWidth <= 768;

        if (isMobile) {
            // Reset sidebar position for mobile
            sidebar.style.top = '0';
        }

        mobileNavToggle.addEventListener('click', function() {
            sidebar.classList.toggle('active');
        });

        // Close sidebar when clicking on a link (mobile)
        const sidebarLinks = sidebar.querySelectorAll('a');
        sidebarLinks.forEach(link => {
            link.addEventListener('click', function() {
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('active');
                }
            });
        });

        // Close sidebar when clicking outside (mobile)
        document.addEventListener('click', function(event) {
            if (window.innerWidth <= 768) {
                const isClickInsideSidebar = sidebar.contains(event.target);
                const isClickOnToggle = mobileNavToggle.contains(event.target);
                
                if (!isClickInsideSidebar && !isClickOnToggle && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                }
            }
        });


    </script>
</body>
</html>